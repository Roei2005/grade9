<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>חוקרים את הדלתון - אלוגברה</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;500;700;900&display=swap" rel="stylesheet">
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body {
            font-family: 'Rubik', sans-serif;
            background-color: #f5f3ff; /* Violet-50 */
            overscroll-behavior: none;
        }
        
        /* Canvas Styling */
        .canvas-container {
            background-color: white;
            background-image: 
                linear-gradient(#ddd6fe 1px, transparent 1px),
                linear-gradient(90deg, #ddd6fe 1px, transparent 1px);
            background-size: 20px 20px;
            background-position: center center;
            touch-action: none;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.02);
        }

        /* Interaction Elements */
        .vertex-point {
            cursor: move;
            transition: r 0.2s, fill 0.2s, stroke-width 0.2s;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.2));
        }
        .vertex-point:active {
            cursor: grabbing;
            r: 12;
            stroke-width: 4;
        }
        
        /* Buttons */
        .btn-prop {
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .btn-prop:hover {
            transform: translateY(-1px);
        }
        .btn-prop.active {
            background-color: #7c3aed; /* Violet-600 */
            color: white;
            border-color: #6d28d9;
            box-shadow: 0 4px 6px -1px rgba(124, 58, 237, 0.3);
        }

        .fade-in {
            animation: fadeIn 0.4s ease-out forwards;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .math-text {
            font-family: 'Rubik', sans-serif;
            font-weight: 700;
            text-shadow: 2px 2px 0px white, -2px -2px 0px white, 2px -2px 0px white, -2px 2px 0px white;
            pointer-events: none;
            user-select: none;
        }
    </style>
</head>
<body class="h-screen flex flex-col text-slate-800 overflow-hidden">

    <!-- Professional Header -->
    <header class="bg-white/90 backdrop-blur-md shadow-sm border-b border-violet-100 z-20 shrink-0">
        <div class="max-w-7xl mx-auto px-4 py-3 flex items-center justify-between">
            <div class="flex items-center gap-2">
                <div class="bg-violet-600 text-white p-1.5 rounded-lg">
                    <i data-lucide="triangle" width="24" height="24" style="transform: rotate(180deg);"></i>
                </div>
                <div>
                    <h1 class="text-xl font-bold text-slate-800 leading-none">חוקרים את הדלתון</h1>
                    <p class="text-xs text-violet-500 font-medium mt-1">מעבדה אינטראקטיבית מבית אלוגברה</p>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Workspace -->
    <main class="flex-grow flex flex-col md:flex-row overflow-hidden relative">
        
        <!-- Canvas Area -->
        <div class="relative w-full md:w-2/3 h-[50vh] md:h-auto border-b md:border-b-0 md:border-l border-violet-200 canvas-container flex justify-center items-center overflow-hidden" id="canvasWrapper">
            <svg id="geoCanvas" width="100%" height="100%" class="w-full h-full select-none block">
                <!-- SVG Content generated by JS -->
            </svg>
            
            <!-- Floating Hint -->
            <div id="dragHint" class="absolute bottom-6 left-1/2 transform -translate-x-1/2 bg-white/90 backdrop-blur border border-violet-200 px-4 py-2 rounded-full text-sm font-semibold text-violet-700 shadow-lg pointer-events-none flex items-center gap-2 animate-pulse">
                <i data-lucide="hand" width="16"></i>
                גררו את הקודקודים לשינוי הדלתון
            </div>
        </div>

        <!-- Controls Sidebar -->
        <div class="w-full md:w-1/3 bg-white flex flex-col h-[50vh] md:h-auto border-t md:border-t-0 shadow-[-5px_0_15px_-5px_rgba(0,0,0,0.05)] z-10">
            <div class="p-6 flex flex-col h-full overflow-y-auto custom-scrollbar">
                
                <h2 class="text-sm font-bold text-slate-400 uppercase tracking-wider mb-4">תכונות הדלתון</h2>
                
                <div class="grid grid-cols-2 gap-3 mb-6">
                    <button onclick="setMode('family')" id="btn-family" class="btn-prop p-3 rounded-xl border border-violet-100 bg-violet-50 text-slate-700 hover:bg-white hover:border-violet-300 flex flex-col items-center justify-center gap-2">
                        <i data-lucide="sparkles" width="22"></i>
                        <span class="text-sm font-bold">הייחודיות</span>
                    </button>
                    <button onclick="setMode('sides')" id="btn-sides" class="btn-prop p-3 rounded-xl border border-violet-100 bg-violet-50 text-slate-700 hover:bg-white hover:border-violet-300 flex flex-col items-center justify-center gap-2">
                        <i data-lucide="copy" width="22"></i>
                        <span class="text-sm font-bold">צלעות וזוויות</span>
                    </button>
                    <button onclick="setMode('diagonals')" id="btn-diagonals" class="btn-prop p-3 rounded-xl border border-violet-100 bg-violet-50 text-slate-700 hover:bg-white hover:border-violet-300 flex flex-col items-center justify-center gap-2">
                        <i data-lucide="crosshair" width="22"></i>
                        <span class="text-sm font-bold">אלכסונים</span>
                    </button>
                    <button onclick="setMode('mistakes')" id="btn-mistakes" class="btn-prop p-3 rounded-xl border border-red-100 bg-red-50 text-red-700 hover:bg-white hover:border-red-300 flex flex-col items-center justify-center gap-2">
                        <i data-lucide="alert-triangle" width="22"></i>
                        <span class="text-sm font-bold">טעויות נפוצות</span>
                    </button>
                </div>

                <div class="border-t border-violet-100 my-2"></div>

                <!-- Reset Button -->
                <button onclick="resetShape()" class="w-full py-3 text-slate-500 hover:text-violet-600 font-medium text-sm flex items-center justify-center gap-2 transition-colors mb-4">
                    <i data-lucide="rotate-ccw" width="18"></i>
                    איפוס לוח
                </button>

                <!-- Info Card -->
                <div class="bg-violet-50/80 p-5 rounded-2xl border border-violet-200 flex-grow relative overflow-hidden group">
                    <div class="relative z-10">
                        <h3 id="infoTitle" class="font-bold text-lg text-violet-900 mb-2 flex items-center gap-2">
                            הדלתון
                        </h3>
                        <div id="infoContent" class="text-violet-900 text-sm leading-relaxed">
                            <!-- Content dynamic -->
                        </div>
                    </div>
                </div>

                <!-- Copyright Footer -->
                <div class="mt-6 text-center">
                    <p class="text-xs font-medium text-violet-300">© כל הזכויות שמורות לאלוגברה</p>
                </div>
            </div>
        </div>
    </main>

<script>
    // --- State & Config ---
    const canvas = document.getElementById('geoCanvas');
    const wrapper = document.getElementById('canvasWrapper');
    let width, height;

    let currentMode = 'family'; 
    let activePoint = null;

    // Kite Logic
    let kite = {
        cx: 0.5,
        ay: 0.15, // Top Y
        cy: 0.85, // Bottom Y
        midY: 0.4, // Where the cross happens
        width: 0.3 // Half width
    };

    // --- Colors ---
    const COLORS = {
        primary: '#7c3aed', // Violet 600
        secondary: '#ec4899', // Pink 500
        accent: '#f59e0b', // Amber 500
        mistake: '#ef4444', // Red 500
        text: '#1e293b', // Slate 800
        fill: 'rgba(139, 92, 246, 0.05)' // Violet tint
    };

    // --- Initialization ---
    function init() {
        lucide.createIcons();
        resizeCanvas();
        window.addEventListener('resize', () => { resizeCanvas(); render(); });
        
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('touchstart', handleStart, {passive: false});
        
        window.addEventListener('mousemove', handleMove);
        window.addEventListener('touchmove', handleMove, {passive: false});
        
        window.addEventListener('mouseup', handleEnd);
        window.addEventListener('touchend', handleEnd);

        setMode('family'); 
    }

    function resizeCanvas() {
        const rect = wrapper.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        canvas.setAttribute('width', width);
        canvas.setAttribute('height', height);
        canvas.setAttribute('viewBox', `0 0 ${width} ${height}`);
    }

    // --- Math Utilities ---
    function toAbs(nx, ny) { return { x: nx * width, y: ny * height }; }
    function toNorm(x, y) { return { x: x / width, y: y / height }; }
    function dist(p1, p2) { return Math.hypot(p2.x - p1.x, p2.y - p1.y); }

    function getAngleDeg(p1, p2, p3) {
        const dx1 = p1.x - p2.x; const dy1 = p1.y - p2.y;
        const dx3 = p3.x - p2.x; const dy3 = p3.y - p2.y;
        const dot = dx1*dx3 + dy1*dy3;
        const mag1 = Math.sqrt(dx1*dx1 + dy1*dy1);
        const mag3 = Math.sqrt(dx3*dx3 + dy3*dy3);
        const cos = dot / (mag1 * mag3);
        return Math.acos(Math.max(-1, Math.min(1, cos))) * 180 / Math.PI;
    }

    function getCorners() {
        const A = toAbs(kite.cx, kite.ay);
        const C = toAbs(kite.cx, kite.cy);
        const B = toAbs(kite.cx + kite.width, kite.midY);
        const D = toAbs(kite.cx - kite.width, kite.midY);
        const O = toAbs(kite.cx, kite.midY); 
        return { A, B, C, D, O };
    }

    // --- Interaction ---
    function getPointerPos(evt) {
        const r = canvas.getBoundingClientRect();
        const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
        const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
        return toNorm(clientX - r.left, clientY - r.top);
    }

    function handleStart(evt) {
        if (evt.target.classList.contains('vertex-point') || evt.type === 'touchstart') {
            evt.preventDefault(); 
        }
        const pos = getPointerPos(evt);
        const pts = getCorners();
        let closest = null;
        let minDist = 40; 

        ['A', 'B', 'C'].forEach(k => { 
            const p = pts[k];
            const px = p.x; const py = p.y;
            const mx = pos.x * width; const my = pos.y * height;
            const d = Math.hypot(px - mx, py - my);
            if (d < minDist) { minDist = d; closest = k; }
        });

        if (closest) {
            activePoint = closest;
            document.body.style.cursor = 'grabbing';
            render();
        }
    }

    function handleMove(evt) {
        if (!activePoint) return;
        evt.preventDefault();
        const pos = getPointerPos(evt);
        const pad = 0.05;
        let ny = Math.max(pad, Math.min(1-pad, pos.y));
        let nx = Math.max(pad, Math.min(1-pad, pos.x));

        if (activePoint === 'A') {
            kite.ay = Math.min(ny, kite.midY - 0.05);
        } else if (activePoint === 'C') {
            kite.cy = Math.max(ny, kite.midY + 0.05);
        } else if (activePoint === 'B') {
            kite.width = Math.max(0.1, Math.abs(nx - kite.cx));
            kite.midY = Math.max(kite.ay + 0.05, Math.min(kite.cy - 0.05, ny));
        }
        render();
    }

    function handleEnd() {
        activePoint = null;
        document.body.style.cursor = 'default';
        render();
    }

    function resetShape() {
        kite = { cx: 0.5, ay: 0.15, cy: 0.85, midY: 0.4, width: 0.3 };
        setMode('family');
    }

    // --- UI Logic ---
    function setMode(mode) {
        currentMode = mode;
        document.querySelectorAll('.btn-prop').forEach(b => b.classList.remove('active'));
        const btn = document.getElementById('btn-' + mode);
        if(btn) btn.classList.add('active');
        updateInfoPanel();
        render();
    }

    function updateInfoPanel() {
        const title = document.getElementById('infoTitle');
        const content = document.getElementById('infoContent');
        content.parentElement.parentElement.classList.remove('fade-in');
        void content.offsetWidth;
        
        let data = { title: "", text: "" };

        switch(currentMode) {
            case 'family':
                data = { 
                    title: "האח המיוחד", 
                    text: `הדלתון הוא "האח" המיוחד של המקבילית. יש לו תכונה חשובה:<br>
                           הוא בנוי מ<b>שני משולשים שווי שוקיים</b> (ABD ו-CBD) שמחוברים בבסיס המשותף שלהם (האלכסון BD).`
                };
                break;
            case 'sides':
                data = { 
                    title: "צלעות וזוויות צד", 
                    text: `1. <b>צלעות סמוכות שוות:</b> הזוג העליון שווה (AB=AD) והזוג התחתון שווה (CB=CD).<br>
                           2. <b>זוויות הצד שוות:</b> שימו לב לערכים בשרטוט! הזווית <span class="font-bold text-violet-700">∠B</span> שווה בדיוק לזווית <span class="font-bold text-violet-700">∠D</span>.`
                };
                break;
            case 'diagonals':
                data = { 
                    title: "אלכסונים: ראשי ומשני", 
                    text: `<b>אלכסון ראשי (AC):</b> הוא ציר הסימטריה. הוא <b>חוצה</b> את המשני, <b>מאונך</b> לו, וחוצה את זוויות הראש.<br>
                           <b>אלכסון משני (BD):</b> מחבר את הקודקודים הצדדיים.`
                };
                break;
            case 'mistakes':
                data = { 
                    title: "⚠️ טעויות נפוצות", 
                    text: `שימו לב!<br>
                           1. זוויות הראש (A ו-C) <b>אינן שוות</b> זו לזו!<br>
                           2. האלכסון הראשי <b>אינו נחצה</b> (AO לא שווה ל-CO).<br>
                           הדלתון אינו מקבילית!`
                };
                break;
        }

        title.innerHTML = data.title;
        content.innerHTML = data.text;
        content.parentElement.parentElement.classList.add('fade-in');
    }

    // --- Rendering Helpers ---
    function createEl(type, attrs) {
        const el = document.createElementNS("http://www.w3.org/2000/svg", type);
        for (let k in attrs) el.setAttribute(k, attrs[k]);
        return el;
    }

    function render() {
        canvas.innerHTML = '';
        const { A, B, C, D, O } = getCorners();
        
        // Fill
        canvas.appendChild(createEl('polygon', {
            points: `${A.x},${A.y} ${B.x},${B.y} ${C.x},${C.y} ${D.x},${D.y}`,
            fill: COLORS.fill, stroke: 'none'
        }));

        // Mode Layers
        if (currentMode === 'diagonals') drawDiagonalsVisuals(A, B, C, D, O);
        else if (currentMode === 'sides') drawSidesVisuals(A, B, C, D);
        else if (currentMode === 'mistakes') drawMistakesVisuals(A, B, C, D, O);
        else if (currentMode === 'family') {
             drawSidesVisuals(A,B,C,D, true); 
        }

        // Outline
        canvas.appendChild(createEl('polygon', {
            points: `${A.x},${A.y} ${B.x},${B.y} ${C.x},${C.y} ${D.x},${D.y}`,
            fill: 'none', stroke: COLORS.primary, 'stroke-width': 4, 'stroke-linejoin': 'round'
        }));

        // Vertices
        drawVertices({A, B, C, D});
    }

    // --- Drawers ---

    function drawSidesVisuals(A, B, C, D, showIsoscelesHint = false) {
        // Lines
        canvas.appendChild(createEl('line', { x1:A.x, y1:A.y, x2:B.x, y2:B.y, stroke: COLORS.primary, 'stroke-width': 5 }));
        canvas.appendChild(createEl('line', { x1:A.x, y1:A.y, x2:D.x, y2:D.y, stroke: COLORS.primary, 'stroke-width': 5 }));
        canvas.appendChild(createEl('line', { x1:C.x, y1:C.y, x2:B.x, y2:B.y, stroke: COLORS.secondary, 'stroke-width': 5 }));
        canvas.appendChild(createEl('line', { x1:C.x, y1:C.y, x2:D.x, y2:D.y, stroke: COLORS.secondary, 'stroke-width': 5 }));

        // Ticks
        drawTick(A, B, 1, COLORS.primary);
        drawTick(A, D, 1, COLORS.primary);
        drawTick(C, B, 2, COLORS.secondary);
        drawTick(C, D, 2, COLORS.secondary);

        // Display Angles B and D
        const angB = Math.round(getAngleDeg(A, B, C));
        const angD = Math.round(getAngleDeg(A, D, C));
        
        // Draw Arc without bg
        drawAngleArcSimple(B, A, C, COLORS.text);
        drawAngleArcSimple(D, C, A, COLORS.text);
        
        // Text inside the shape
        // Shift text towards center
        const shiftX = 45;
        drawSimpleText(B.x - shiftX, B.y, `${angB}°`, COLORS.text);
        drawSimpleText(D.x + shiftX, D.y, `${angD}°`, COLORS.text);
        
        if(showIsoscelesHint) {
            canvas.appendChild(createEl('line', { x1:B.x, y1:B.y, x2:D.x, y2:D.y, stroke: COLORS.text, 'stroke-width': 2, 'stroke-dasharray': '6,4', opacity: 0.6 }));
        }
    }

    function drawDiagonalsVisuals(A, B, C, D, O) {
        canvas.appendChild(createEl('line', { x1:A.x, y1:A.y, x2:C.x, y2:C.y, stroke: COLORS.accent, 'stroke-width': 4, 'stroke-dasharray':'10,6' }));
        canvas.appendChild(createEl('line', { x1:B.x, y1:B.y, x2:D.x, y2:D.y, stroke: COLORS.text, 'stroke-width': 3 }));

        // Draw Right Angle squares in all 4 quadrants
        const s = 14;
        // Top-Right (relative to O, axis flipped usually in SVG y grows down)
        canvas.appendChild(createEl('rect', { x: O.x, y: O.y - s, width: s, height: s, fill: 'none', stroke: COLORS.text, 'stroke-width': 1 }));
        // Top-Left
        canvas.appendChild(createEl('rect', { x: O.x - s, y: O.y - s, width: s, height: s, fill: 'none', stroke: COLORS.text, 'stroke-width': 1 }));
        // Bottom-Right
        canvas.appendChild(createEl('rect', { x: O.x, y: O.y, width: s, height: s, fill: 'none', stroke: COLORS.text, 'stroke-width': 1 }));
        // Bottom-Left
        canvas.appendChild(createEl('rect', { x: O.x - s, y: O.y, width: s, height: s, fill: 'none', stroke: COLORS.text, 'stroke-width': 1 }));
        
        canvas.appendChild(createEl('circle', { cx: O.x, cy: O.y, r: 2, fill: COLORS.text }));

        drawTick(O, B, 3, COLORS.text);
        drawTick(O, D, 3, COLORS.text);

        drawLabelText(A.x, A.y - 35, "ראש", COLORS.primary);
        drawLabelText(C.x, C.y + 35, "ראש", COLORS.primary);
        drawLabelText(B.x + 50, B.y, "צד", COLORS.text);
        
        // Angle bisector visual
        drawAngleArcSimple(A, D, B, COLORS.accent);
        drawAngleArcSimple(C, B, D, COLORS.accent);
    }

    function drawMistakesVisuals(A, B, C, D, O) {
        canvas.appendChild(createEl('line', { x1:B.x, y1:B.y, x2:D.x, y2:D.y, stroke: COLORS.text, 'stroke-width': 1, opacity: 0.5 }));
        
        canvas.appendChild(createEl('circle', { cx: O.x, cy: O.y, r: 4, fill: COLORS.text }));
        const tO = createEl('text', { x: O.x + 15, y: O.y - 15, fill: COLORS.text, 'font-size': 18, 'font-weight': 'bold', class: 'math-text' });
        tO.textContent = 'O';
        canvas.appendChild(tO);

        const arcA = createEl('path', { d: `M ${A.x-20} ${A.y+35} Q ${A.x} ${A.y+50} ${A.x+20} ${A.y+35}`, fill:'none', stroke: COLORS.mistake, 'stroke-width':4 });
        const arcC = createEl('path', { d: `M ${C.x-30} ${C.y-30} Q ${C.x} ${C.y-60} ${C.x+30} ${C.y-30}`, fill:'none', stroke: COLORS.primary, 'stroke-width':4 });
        
        canvas.appendChild(arcA);
        canvas.appendChild(arcC);

        const t1 = createEl('text', { x: width - 80, y: height/2 - 30, fill: COLORS.mistake, 'font-size': 20, 'font-weight':'bold', 'text-anchor':'middle', class:'math-text'});
        t1.textContent = "∠A ≠ ∠C";
        canvas.appendChild(t1);

        const t2 = createEl('text', { x: width - 80, y: height/2 + 30, fill: COLORS.mistake, 'font-size': 20, 'font-weight':'bold', 'text-anchor':'middle', class:'math-text'});
        t2.textContent = "AO ≠ CO";
        canvas.appendChild(t2);

        canvas.appendChild(createEl('line', { x1:A.x, y1:A.y, x2:O.x, y2:O.y, stroke: COLORS.mistake, 'stroke-width':4 }));
        drawXMark((A.x+O.x)/2, (A.y+O.y)/2, COLORS.mistake);
        
        canvas.appendChild(createEl('line', { x1:C.x, y1:C.y, x2:O.x, y2:O.y, stroke: COLORS.primary, 'stroke-width':4 }));
    }

    // --- Helpers ---
    function drawTick(p1, p2, count, color) {
        const mx = (p1.x + p2.x)/2; const my = (p1.y + p2.y)/2;
        const dx = p2.x - p1.x; const dy = p2.y - p1.y;
        const len = Math.hypot(dx, dy);
        const nx = -dy/len * 8; const ny = dx/len * 8;
        
        for(let i=0; i<count; i++) {
            const shift = (i - (count-1)/2) * 6;
            const bx = mx + (dx/len)*shift; const by = my + (dy/len)*shift;
            canvas.appendChild(createEl('line', {
                x1: bx - nx, y1: by - ny, x2: bx + nx, y2: by + ny,
                stroke: color, 'stroke-width': 3
            }));
        }
    }

    function drawXMark(x, y, color) {
        const s = 10;
        canvas.appendChild(createEl('line', { x1: x-s, y1: y-s, x2: x+s, y2: y+s, stroke: color, 'stroke-width': 4 }));
        canvas.appendChild(createEl('line', { x1: x+s, y1: y-s, x2: x-s, y2: y+s, stroke: color, 'stroke-width': 4 }));
    }

    function drawAngleArcSimple(center, p1, p2, color) {
        const r = 35;
        // Simple arc approx for visual
        const dx1 = p1.x - center.x; const dy1 = p1.y - center.y;
        const dx2 = p2.x - center.x; const dy2 = p2.y - center.y;
        const l1 = Math.hypot(dx1, dy1); const l2 = Math.hypot(dx2, dy2);
        
        const startX = center.x + (dx1/l1)*r; const startY = center.y + (dy1/l1)*r;
        const endX = center.x + (dx2/l2)*r; const endY = center.y + (dy2/l2)*r;
        
        // Control point for curve
        const midX = (startX + endX)/2; const midY = (startY + endY)/2;
        const cx = center.x + (midX - center.x)*1.2;
        const cy = center.y + (midY - center.y)*1.2;

        canvas.appendChild(createEl('path', {
            d: `M ${startX} ${startY} Q ${cx} ${cy} ${endX} ${endY}`,
            fill: 'none', stroke: color, 'stroke-width': 2
        }));
    }

    function drawSimpleText(x, y, txt, color) {
        const t = createEl('text', { x: x, y: y+5, fill: color, 'font-size':16, 'font-weight':'bold', 'text-anchor':'middle', class:'math-text' });
        t.textContent = txt;
        canvas.appendChild(t);
    }

    function drawLabelText(x, y, txt, color) {
        const bg = createEl('rect', { x: x-25, y: y-12, width:50, height:24, rx:6, fill:'white', opacity:0.9 });
        canvas.appendChild(bg);
        const t = createEl('text', { x: x, y: y+6, fill: color, 'font-size':14, 'font-weight':'bold', 'text-anchor':'middle', class:'math-text' });
        t.textContent = txt;
        canvas.appendChild(t);
    }

    function drawVertices(pts) {
        for(let k in pts) {
            const p = pts[k];
            const isActive = activePoint === k;
            if (isActive) canvas.appendChild(createEl('circle', { cx: p.x, cy: p.y, r: 20, fill: COLORS.primary, opacity: 0.2 }));
            
            const isDraggable = (k !== 'D');
            const fill = isDraggable ? (isActive ? COLORS.primary : 'white') : '#cbd5e1';
            canvas.appendChild(createEl('circle', { 
                cx: p.x, cy: p.y, r: 8, fill: fill, 
                stroke: COLORS.primary, 'stroke-width': 3, 
                class: isDraggable ? 'vertex-point' : ''
            }));
            const t = createEl('text', { x: p.x + (k==='D'?-25:25), y: p.y + (k==='A'?-20:30), fill: COLORS.text, 'font-size': 20, 'font-weight':'bold', 'text-anchor':'middle', class:'math-text'});
            t.textContent = k;
            canvas.appendChild(t);
        }
    }

    init();
</script>
</body>
</html>