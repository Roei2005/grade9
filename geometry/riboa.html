<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>חוקרים את הריבוע - אלוגברה</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;500;700;900&display=swap" rel="stylesheet">
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body {
            font-family: 'Rubik', sans-serif;
            background-color: #ecfeff; /* Cyan-50 */
            overscroll-behavior: none;
        }
        
        .canvas-container {
            background-color: white;
            background-image: 
                linear-gradient(#cffafe 1px, transparent 1px),
                linear-gradient(90deg, #cffafe 1px, transparent 1px);
            background-size: 20px 20px;
            background-position: center center;
            touch-action: none;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.02);
        }

        .vertex-point {
            cursor: move;
            transition: r 0.2s, fill 0.2s, stroke-width 0.2s;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.2));
        }
        .vertex-point:active {
            cursor: grabbing;
            r: 12;
            stroke-width: 4;
        }
        
        .btn-prop {
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .btn-prop:hover {
            transform: translateY(-1px);
        }
        .btn-prop.active {
            background-color: #0891b2; /* Cyan-600 */
            color: white;
            border-color: #0e7490;
            box-shadow: 0 4px 6px -1px rgba(8, 145, 178, 0.3);
        }

        .fade-in {
            animation: fadeIn 0.4s ease-out forwards;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .math-text {
            font-family: 'Rubik', sans-serif;
            font-weight: 700;
            text-shadow: 2px 2px 0px white, -2px -2px 0px white, 2px -2px 0px white, -2px 2px 0px white;
            pointer-events: none;
            user-select: none;
        }
    </style>
</head>
<body class="h-screen flex flex-col text-slate-800 overflow-hidden">

    <header class="bg-white/90 backdrop-blur-md shadow-sm border-b border-cyan-100 z-20 shrink-0">
        <div class="max-w-7xl mx-auto px-4 py-3 flex items-center justify-between">
            <div class="flex items-center gap-2">
                <div class="bg-cyan-600 text-white p-1.5 rounded-lg">
                    <i data-lucide="square" width="24" height="24"></i>
                </div>
                <div>
                    <h1 class="text-xl font-bold text-slate-800 leading-none">חוקרים את הריבוע</h1>
                    <p class="text-xs text-cyan-600 font-medium mt-1">מעבדה אינטראקטיבית מבית אלוגברה</p>
                </div>
            </div>
        </div>
    </header>

    <main class="flex-grow flex flex-col md:flex-row overflow-hidden relative">
        
        <!-- Canvas -->
        <div class="relative w-full md:w-2/3 h-[50vh] md:h-auto border-b md:border-b-0 md:border-l border-cyan-200 canvas-container flex justify-center items-center overflow-hidden" id="canvasWrapper">
            <svg id="geoCanvas" width="100%" height="100%" class="w-full h-full select-none block">
                <!-- SVG Content -->
            </svg>
            <div id="dragHint" class="absolute bottom-6 left-1/2 transform -translate-x-1/2 bg-white/90 backdrop-blur border border-cyan-200 px-4 py-2 rounded-full text-sm font-semibold text-cyan-700 shadow-lg pointer-events-none flex items-center gap-2 animate-pulse">
                <i data-lucide="hand" width="16"></i>
                גררו את הקודקודים לשינוי הגודל
            </div>
        </div>

        <!-- Sidebar -->
        <div class="w-full md:w-1/3 bg-white flex flex-col h-[50vh] md:h-auto border-t md:border-t-0 shadow-[-5px_0_15px_-5px_rgba(0,0,0,0.05)] z-10">
            <div class="p-6 flex flex-col h-full overflow-y-auto custom-scrollbar">
                
                <h2 class="text-sm font-bold text-slate-400 uppercase tracking-wider mb-4">תכונות הריבוע</h2>
                
                <div class="grid grid-cols-2 gap-3 mb-6">
                    <button onclick="setMode('family')" id="btn-family" class="btn-prop p-3 rounded-xl border border-cyan-100 bg-cyan-50 text-slate-700 hover:bg-white hover:border-cyan-300 flex flex-col items-center justify-center gap-2">
                        <i data-lucide="crown" width="22"></i>
                        <span class="text-sm font-bold">הצאצא המושלם</span>
                    </button>
                    <button onclick="setMode('sides')" id="btn-sides" class="btn-prop p-3 rounded-xl border border-cyan-100 bg-cyan-50 text-slate-700 hover:bg-white hover:border-cyan-300 flex flex-col items-center justify-center gap-2">
                        <i data-lucide="layout-grid" width="22"></i>
                        <span class="text-sm font-bold">צלעות וזוויות</span>
                    </button>
                    <button onclick="setMode('diagonals')" id="btn-diagonals" class="btn-prop p-3 rounded-xl border border-cyan-100 bg-cyan-50 text-slate-700 hover:bg-white hover:border-cyan-300 flex flex-col items-center justify-center gap-2">
                        <i data-lucide="x" width="22"></i>
                        <span class="text-sm font-bold">אלכסונים ו-45°</span>
                    </button>
                    <button onclick="setMode('all')" id="btn-all" class="btn-prop p-3 rounded-xl border border-cyan-100 bg-cyan-50 text-slate-700 hover:bg-white hover:border-cyan-300 flex flex-col items-center justify-center gap-2">
                        <i data-lucide="check-circle-2" width="22"></i>
                        <span class="text-sm font-bold">הכל כלול</span>
                    </button>
                    <button onclick="setMode('area')" id="btn-area" class="btn-prop col-span-2 p-3 rounded-xl border border-cyan-100 bg-cyan-50 text-slate-700 hover:bg-white hover:border-cyan-300 flex flex-row items-center justify-center gap-2">
                        <i data-lucide="scaling" width="22"></i>
                        <span class="text-sm font-bold">שטח הריבוע</span>
                    </button>
                </div>

                <div class="border-t border-cyan-100 my-2"></div>

                <button onclick="resetShape()" class="w-full py-3 text-slate-500 hover:text-cyan-600 font-medium text-sm flex items-center justify-center gap-2 transition-colors mb-4">
                    <i data-lucide="rotate-ccw" width="18"></i>
                    איפוס לוח
                </button>

                <!-- Info Card -->
                <div class="bg-cyan-50/80 p-5 rounded-2xl border border-cyan-200 flex-grow relative overflow-hidden group">
                    <div class="relative z-10">
                        <h3 id="infoTitle" class="font-bold text-lg text-cyan-900 mb-2 flex items-center gap-2">
                            הריבוע
                        </h3>
                        <div id="infoContent" class="text-cyan-900 text-sm leading-relaxed">
                            <!-- Dynamic Content -->
                        </div>
                    </div>
                </div>

                <div class="mt-6 text-center">
                    <p class="text-xs font-medium text-cyan-300">© כל הזכויות שמורות לאלוגברה</p>
                </div>
            </div>
        </div>
    </main>

<script>
    // --- State ---
    const canvas = document.getElementById('geoCanvas');
    const wrapper = document.getElementById('canvasWrapper');
    let width, height;

    let currentMode = 'family';
    let activePoint = null;

    // Square Logic: Defined by center and half-width (s)
    let square = {
        cx: 0.5,
        cy: 0.5,
        s: 0.25 // half side length relative to canvas
    };

    const COLORS = {
        primary: '#0891b2', // Cyan 600
        secondary: '#ec4899', // Pink 500
        accent: '#f59e0b', // Amber 500
        text: '#1e293b', 
        fill: 'rgba(6, 182, 212, 0.05)'
    };

    // --- Init ---
    function init() {
        lucide.createIcons();
        resizeCanvas();
        window.addEventListener('resize', () => { resizeCanvas(); render(); });
        
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('touchstart', handleStart, {passive: false});
        window.addEventListener('mousemove', handleMove);
        window.addEventListener('touchmove', handleMove, {passive: false});
        window.addEventListener('mouseup', handleEnd);
        window.addEventListener('touchend', handleEnd);

        setMode('family');
    }

    function resizeCanvas() {
        const rect = wrapper.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        canvas.setAttribute('width', width);
        canvas.setAttribute('height', height);
        canvas.setAttribute('viewBox', `0 0 ${width} ${height}`);
    }

    // --- Math ---
    function toAbs(nx, ny) { return { x: nx * width, y: ny * height }; }
    function toNorm(x, y) { return { x: x / width, y: y / height }; }
    function dist(p1, p2) { return Math.hypot(p2.x - p1.x, p2.y - p1.y); }

    function getCorners() {
        // Simple axis-aligned square for clarity
        const A = toAbs(square.cx - square.s, square.cy - square.s);
        const B = toAbs(square.cx + square.s, square.cy - square.s);
        const C = toAbs(square.cx + square.s, square.cy + square.s);
        const D = toAbs(square.cx - square.s, square.cy + square.s);
        const O = toAbs(square.cx, square.cy);
        return { A, B, C, D, O };
    }

    // --- Interaction ---
    function getPointerPos(evt) {
        const r = canvas.getBoundingClientRect();
        const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
        const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
        return toNorm(clientX - r.left, clientY - r.top);
    }

    function handleStart(evt) {
        if (evt.target.classList.contains('vertex-point') || evt.type === 'touchstart') evt.preventDefault();
        const pos = getPointerPos(evt);
        const pts = getCorners();
        let closest = null, minDist = 40;

        ['A', 'B', 'C', 'D'].forEach(k => {
            const p = pts[k];
            const d = Math.hypot(p.x - pos.x * width, p.y - pos.y * height);
            if(d < minDist) { minDist = d; closest = k; }
        });

        if(closest) {
            activePoint = closest;
            document.body.style.cursor = 'grabbing';
            render();
        }
    }

    function handleMove(evt) {
        if(!activePoint) return;
        evt.preventDefault();
        const pos = getPointerPos(evt);
        const pad = 0.05;
        let nx = Math.max(pad, Math.min(1-pad, pos.x));
        let ny = Math.max(pad, Math.min(1-pad, pos.y));

        // Logic: Resize symmetrically from center
        // Just calculate distance from center to mouse and set as new size
        // We constrain it to be a square
        let dx = Math.abs(nx - square.cx);
        let dy = Math.abs(ny - square.cy);
        let newS = Math.max(dx, dy); // Take largest to avoid collapse
        
        square.s = Math.max(0.1, Math.min(0.45, newS));
        render();
    }

    function handleEnd() {
        activePoint = null;
        document.body.style.cursor = 'default';
        render();
    }

    function resetShape() {
        square.s = 0.25;
        render();
    }

    // --- UI Logic ---
    function setMode(mode) {
        currentMode = mode;
        document.querySelectorAll('.btn-prop').forEach(b => b.classList.remove('active'));
        const btn = document.getElementById('btn-' + mode);
        if(btn) btn.classList.add('active');
        
        updateInfoPanel();
        render();
    }

    function updateInfoPanel() {
        const title = document.getElementById('infoTitle');
        const content = document.getElementById('infoContent');
        content.parentElement.parentElement.classList.remove('fade-in');
        void content.offsetWidth;
        
        let data = { title: "", text: "" };

        switch(currentMode) {
            case 'family':
                data = { 
                    title: "הצאצא המושלם", 
                    text: `הריבוע הוא המרובע המושלם ביותר במשפחה. הוא ירש <b>הכל</b> מההורים שלו:<br>
                           מאבא מלבן הוא קיבל <b>זוויות ישרות</b> ואלכסונים שווים.<br>
                           מאמא מעוין הוא קיבל <b>צלעות שוות</b>, אלכסונים מאונכים וחוצי זווית.`
                };
                break;
            case 'sides':
                data = { 
                    title: "צלעות וזוויות", 
                    text: `1. כל 4 הצלעות <b>שוות</b> באורכן.<br>
                           2. כל 4 הזוויות הן <b>ישרות</b> (90°).<br>
                           (זוויות נגדיות שוות, וצלעות נגדיות מקבילות - כמו אצל הסבתא מקבילית).`
                };
                break;
            case 'diagonals':
                data = { 
                    title: "האלכסונים וה-45 מעלות", 
                    text: `האלכסונים בריבוע הם שיא השלמות:<br>
                           1. הם <b>שווים</b> באורכם.<br>
                           2. הם <b>חוצים</b> זה את זה.<br>
                           3. הם <b>מאונכים</b> זה לזה.<br>
                           4. והכי חשוב: הם <b>חוצים את הזוויות</b> ל-45°!`
                };
                break;
            case 'all':
                data = { 
                    title: "הכל כלול", 
                    text: `ריבוע הוא בעצם גם מקבילית, גם מלבן וגם מעוין.<br>
                           יש לו את <b>כל</b> התכונות האפשריות למרובע ממשפחת המקביליות.`
                };
                break;
            case 'area':
                data = { 
                    title: "שטח הריבוע", 
                    text: `
                    אפשר לחשב בשתי דרכים:<br>
                    1. כמו מלבן: <span class="font-bold font-mono text-cyan-700">צלע × צלע</span><br>
                    2. כמו מעוין: <span class="font-bold font-mono text-cyan-700">אלכסון × אלכסון חלקי 2</span>`
                };
                break;
        }

        title.innerHTML = data.title;
        content.innerHTML = data.text;
        content.parentElement.parentElement.classList.add('fade-in');
    }

    // --- Rendering ---
    function createEl(type, attrs) {
        const el = document.createElementNS("http://www.w3.org/2000/svg", type);
        for (let k in attrs) el.setAttribute(k, attrs[k]);
        return el;
    }

    function render() {
        canvas.innerHTML = '';
        const { A, B, C, D, O } = getCorners();
        
        // Fill
        canvas.appendChild(createEl('polygon', {
            points: `${A.x},${A.y} ${B.x},${B.y} ${C.x},${C.y} ${D.x},${D.y}`,
            fill: COLORS.fill, stroke: 'none'
        }));

        // Render Layers based on Mode
        
        if (currentMode === 'sides' || currentMode === 'all') {
            // Right Angles at corners
            drawRightAngle(A, 1, 1);
            drawRightAngle(B, -1, 1);
            drawRightAngle(C, -1, -1);
            drawRightAngle(D, 1, -1);
            
            // Side Ticks
            drawTick(A, B); drawTick(B, C); drawTick(C, D); drawTick(D, A);
        }

        if (currentMode === 'diagonals' || currentMode === 'all' || currentMode === 'area') {
            // Diagonals
            canvas.appendChild(createEl('line', { x1:A.x, y1:A.y, x2:C.x, y2:C.y, stroke: COLORS.accent, 'stroke-width':3 }));
            canvas.appendChild(createEl('line', { x1:B.x, y1:B.y, x2:D.x, y2:D.y, stroke: COLORS.accent, 'stroke-width':3 }));
            
            // Center Right Angle
            drawRightAngle(O, 1, -1, COLORS.accent);
            
            // 45 degree labels
            if (currentMode === 'diagonals' || currentMode === 'all') {
                draw45Label(A, 1, 1);
                draw45Label(B, -1, 1);
                draw45Label(C, -1, -1);
                draw45Label(D, 1, -1);
            }
        }

        if (currentMode === 'area') {
            drawAreaVisuals(A, B, D);
        }

        // Outline
        canvas.appendChild(createEl('polygon', {
            points: `${A.x},${A.y} ${B.x},${B.y} ${C.x},${C.y} ${D.x},${D.y}`,
            fill: 'none', stroke: COLORS.primary, 'stroke-width': 4, 'stroke-linejoin': 'round'
        }));

        drawVertices({A, B, C, D});
    }

    // --- Helpers ---
    function drawRightAngle(p, dx, dy, color=COLORS.text) {
        const s = 15;
        canvas.appendChild(createEl('polyline', {
            points: `${p.x},${p.y + dy*s} ${p.x + dx*s},${p.y + dy*s} ${p.x + dx*s},${p.y}`,
            fill: 'none', stroke: color, 'stroke-width': 2
        }));
        // Dot
        canvas.appendChild(createEl('circle', { cx: p.x + dx*s/2, cy: p.y + dy*s/2, r: 1.5, fill: color }));
    }

    function drawTick(p1, p2) {
        const mx = (p1.x + p2.x)/2; const my = (p1.y + p2.y)/2;
        const dx = p2.x - p1.x; const dy = p2.y - p1.y;
        const len = Math.hypot(dx, dy);
        const nx = -dy/len * 8; const ny = dx/len * 8;
        canvas.appendChild(createEl('line', {
            x1: mx - nx, y1: my - ny, x2: mx + nx, y2: my + ny,
            stroke: COLORS.primary, 'stroke-width': 3
        }));
    }

    function draw45Label(corner, dx, dy) {
        const r = 45; // dist from corner
        // Angle 1
        const t1 = createEl('text', { 
            x: corner.x + dx*r*0.4, y: corner.y + dy*r*0.9, 
            fill: COLORS.text, 'font-size': 12, 'font-weight':'bold', 'text-anchor':'middle' 
        });
        t1.textContent = "45°";
        // Angle 2
        const t2 = createEl('text', { 
            x: corner.x + dx*r*0.9, y: corner.y + dy*r*0.4, 
            fill: COLORS.text, 'font-size': 12, 'font-weight':'bold', 'text-anchor':'middle' 
        });
        t2.textContent = "45°";
        
        canvas.appendChild(t1);
        canvas.appendChild(t2);
        
        // Arcs
        canvas.appendChild(createEl('path', {
            d: `M ${corner.x + dx*30} ${corner.y} A 30 30 0 0 ${dx*dy > 0 ? 1 : 0} ${corner.x} ${corner.y + dy*30}`,
            fill: 'none', stroke: COLORS.text, 'stroke-width':1, 'stroke-dasharray':'2,2'
        }));
    }

    function drawAreaVisuals(A, B, D) {
        const sVal = Math.round(dist(A, B)/10);
        
        drawLabelBox((A.x+B.x)/2, A.y - 20, `a = ${sVal}`, COLORS.primary);
        drawLabelBox(A.x - 25, (A.y+D.y)/2, `a = ${sVal}`, COLORS.primary);
        
        const area = sVal * sVal;
        
        // Center Text
        const cx = (A.x + 2*square.s*width)/2; // approximation based on square logic
        const cy = (A.y + 2*square.s*height)/2; // center
        
        const t = createEl('text', {
            x: square.cx * width, y: square.cy * height + 10,
            fill: COLORS.text, 'font-size': 24, 'font-weight': 'bold',
            'text-anchor': 'middle', 'dominant-baseline': 'middle', class: 'math-text'
        });
        t.textContent = `S = ${area}`;
        canvas.appendChild(t);

        const infoContent = document.getElementById('infoContent');
        if (infoContent) {
            infoContent.innerHTML = `
                נוסחת השטח (צלע בריבוע):<br>
                <div class="mt-3 text-center bg-cyan-50 p-3 rounded-lg border border-cyan-200 shadow-sm">
                    <div class="font-mono text-lg text-cyan-800 font-bold" dir="ltr">${sVal} × ${sVal} = ${area}</div>
                </div>
            `;
        }
    }

    function drawLabelBox(x, y, txt, color) {
        canvas.appendChild(createEl('rect', {
            x: x - 25, y: y - 12, width: 50, height: 24, rx: 6,
            fill: 'white', stroke: color, 'stroke-width': 2, opacity: 0.95
        }));
        const t = createEl('text', {
            x: x, y: y+5, fill: color, 'font-size': 14, 'font-weight': 'bold',
            'text-anchor': 'middle', 'dominant-baseline': 'middle', class: 'math-text'
        });
        t.textContent = txt;
        canvas.appendChild(t);
    }

    function drawVertices(pts) {
        for(let k in pts) {
            const p = pts[k];
            const isActive = activePoint === k;
            if (isActive) canvas.appendChild(createEl('circle', { cx: p.x, cy: p.y, r: 22, fill: COLORS.primary, opacity: 0.2 }));
            
            canvas.appendChild(createEl('circle', { 
                cx: p.x, cy: p.y, r: 9, fill: isActive ? COLORS.primary : 'white', 
                stroke: COLORS.primary, 'stroke-width': 3, 
                class: 'vertex-point'
            }));
            const t = createEl('text', { x: p.x + (k==='D'||k==='A'?-25:25), y: p.y + (k==='A'||k==='B'?-20:30), fill: COLORS.text, 'font-size': 20, 'font-weight':'bold', 'text-anchor':'middle', class:'math-text'});
            t.textContent = k;
            canvas.appendChild(t);
        }
    }

    init();
</script>
</body>
</html>